#!/usr/bin/expect -f
# ESC test: spawn the published app and send an Escape key; expect the program to exit and print "Exiting..." within allowed threshold.
# Usage: esc_test.exp <path-to-published-target>

# overall expect timeout for matching operations
set timeout 5

if { $argc < 1 } {
    puts "Usage: $argv0 <published-target-path>"
    exit 2
}
set target [lindex $argv 0]

# Decide how to spawn: if target ends with .dll, run 'dotnet <dll>'; otherwise run the executable directly.
if {[string match "*.dll" $target]} {
    spawn dotnet $target
} else {
    spawn $target
}

# Give program a short moment to initialize
sleep 0.1

# Time threshold (seconds) allowed for the program to exit after sending Escape.
# Increased to 3.0s to account for runtime start/IO in CI.
set allowed_seconds 3.0

set start [clock milliseconds]

# Send ASCII Escape
send "\033"

# Wait for either the explicit "Exiting..." string, EOF (process ended), or timeout
expect {
    -re "Exiting\\.\\.\\." {
        # matched the expected message printed by ExitNow
        puts "ESC test: saw exit message."
    }
    eof {
        # process exited without printing the exact message
        puts "ESC test: process exited (EOF) before or without explicit message."
    }
    timeout {
        puts "ESC test: timeout waiting for exit message or process termination"
        exit 1
    }
}

set elapsed_ms [expr {[clock milliseconds] - $start}]
set elapsed_s [expr {double($elapsed_ms) / 1000.0}]

puts "ESC test: elapsed time = ${elapsed_s}s (allowed ${allowed_seconds}s)"

# Check that the program exited within allowed_seconds
if { $elapsed_s > $allowed_seconds } {
    puts "ESC test FAILED: program did not exit within ${allowed_seconds}s (elapsed ${elapsed_s}s)"
    exit 1
} else {
    puts "ESC test PASSED: program exited in ${elapsed_s}s"
    exit 0
}